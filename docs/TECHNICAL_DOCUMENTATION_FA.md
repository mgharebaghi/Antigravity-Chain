# مستندات فنی جامع پروژه Antigravity Chain

## ۱. معرفی و هدف پروژه (Introduction)
**نام پروژه:** Antigravity Chain (زنجیره ضد جاذبه)

**هدف اصلی:**
این پروژه با هدف ایجاد یک بلاک‌چین نسل جدید، سبک و متمرکز بر کاربر خانگی (Home-User Friendly) طراحی شده است. برخلاف بیت‌کوین که نیاز به سخت‌افزارهای سنگین ماینینگ (ASIC) دارد، یا اتریوم که پیچیدگی‌های زیادی دارد، Antigravity Chain طراحی شده تا روی هر لپ‌تاپ یا سیستم شخصی معمولی اجرا شود.

**فلسفه "ضد جاذبه":**
اشاره به شکستن سنگینی و اینرسی سیستم‌های قدیمی است. این سیستم با استفاده از مکانیزم اجماع خلاقانه، نیاز به مصرف انرژی بالا را از بین برده و سرعت پردازش را به حداکثر رسانده است.

---

## ۲. معماری سیستم (System Architecture)

این پروژه یک **Hybrid Application** است که از قدرت زبان **Rust** برای هسته مرکزی و زیبایی و انعطاف **Web Technologies (React)** برای رابط کاربری استفاده می‌کند. چارچوب اصلی (Framework) مورد استفاده **Tauri v2** است.

### ساختار کلی:
1.  **هسته (Backend - Rust Process):** این بخش "مغز" سیستم است. تمام پردازش‌های سنگین، رمزنگاری، ارتباطات شبکه (P2P)، ذخیره‌سازی داده‌ها و منطق اجماع در اینجا انجام می‌شود. این بخش کاملاً Native اجرا می‌شود و سرعت فوق‌العاده‌ای دارد.
2.  **رابط کاربری (Frontend - Web View):** این بخش "چهره" سیستم است. وظیفه نمایش داده‌ها به کاربر و دریافت ورودی‌ها را دارد. هیچ منطق امنیتی حساسی در فرانت‌اند اجرا نمی‌شود؛ فرانت‌اند فقط یک نمایشگر است.
3.  **پل ارتباطی (IPC Bridge):** ارتباط بین Rust و React از طریق یک مکانیزمсинکرون/آسنکرون بسیار سریع (مبتنی بر JSON) برقرار می‌شود.

---

## ۳. تحلیل عمیق تکنولوژی‌های استفاده شده (Tech Stack Deep Dive)

### الف) Backend (سمت سرور/هسته) - زبان Rust
چرا **Rust**؟
1.  **ایمنی حافظه (Memory Safety):** Rust بدون نیاز به Garbage Collector، امنیت حافظه را تضمین می‌کند. این یعنی کرش‌های ناگهانی یا نشت حافظه (Memory Leaks) که در پروژه‌های طولانی مدت رایج هستند، در اینجا وجود ندارند.
2.  **سرعت (Performance):** کدهای Rust به زبان ماشین کامپایل می‌شوند و سرعتی برابر با C++ دارند.
3.  **همروندی (Concurrency):** مدل Async/Await در Rust (با استفاده از Tokio) اجازه می‌دهد هزاران اتصال شبکه همزمان بدون افت سرعت مدیریت شوند.

**کتابخانه‌های کلیدی (Crates):**
-   `tokio`: موتور اجرایی آسنکرون (Runtime) برای مدیریت همزمان وظایف (Threading).
-   `libp2p`: استاندارد جهانی شبکه‌های همتا-به-همتا (Peer-to-Peer). استفاده شده برای کشف نودها، اتصال امن و پخش اطلاعات.
-   `redb`: یک دیتابیس داخلی (Embedded) فوق سریع و امن برای ذخیره بلاک‌ها و وضعیت کیف پول. جایگزین مدرن برای Sled یا RocksDB.
-   `serde` & `bincode`: برای سریال‌سازی داده‌ها. `bincode` داده‌ها را به باینری فشرده تبدیل می‌کند که پهنای باند شبکه را به شدت کاهش می‌دهد.
-   `ed25519-dalek` (از طریق libp2p identity): برای امضای دیجیتال و احراز هویت تراکنش‌ها (استاندارد نظامی امنیت).

### ب) Frontend (سمت کاربر) - React & Typescript
چرا **React + Vite**؟
1.  **Vite:** بیلد تول (Build Tool) نسل جدید که سرعت توسعه و بیلد نهایی را ده‌ها برابر سریع‌تر از Webpack می‌کند.
2.  **TypeScript:** تضمین می‌کند که داده‌های دریافتی از Rust دقیقاً همان ساختاری را دارند که انتظار می‌رود و باگ‌های تایپی را حذف می‌کند.
3.  **TailwindCSS:** برای استایل‌دهی سریع، مدرن و ریسپانسیو.

---

## ۴. تشریح فایل‌ها و ساختار کد (Codebase Breakdown)

### پوشه `src-tauri/src` (قلب تپنده پروژه)

1.  **`lib.rs` (مدیر اجرایی):**
    -   این فایل نقطه اتصال همه ماژول‌هاست.
    -   تعریف `AppState`: تمام وضعیت‌های برنامه (کیف پول، دیتابیس، کانال‌های ارتباطی) در اینجا نگهداری می‌شوند تا بین تردها (Threads) به اشتراک گذاشته شوند.
    -   **Loop های اصلی:**
        -   `Mining Loop`: حلقه‌ای که هر ثانیه وضعیت شبکه را چک می‌کند و اگر نوبت این نود باشد، بلاک جدید می‌سازد.
        -   `VDF Heartbeat`: ترد جداگانه‌ای که سختی شبکه را محاسبه و اثبات می‌کند که نود "زنده" و فعال است.

2.  **`chain.rs` (منطق بلاک‌چین):**
    -   تعریف `Block`: شامل هِدر (Header)، تراکنش‌ها، هش قبلی، و اثبات VDF.
    -   تعریف `Transaction`: فرستنده، گیرنده، مقدار، امضا.
    -   **Tokenomics**: منطق تولید سکه (Reward) و هاوینگ (Halving) در اینجا قرار دارد. فرمول `calculate_circulating_supply` عرضه در گردش را محاسبه می‌کند.
    -   **Merkle Tree**: تابع `calculate_merkle_root` تمام تراکنش‌ها را هش کرده و به یک ریشه‌ی واحد تبدیل می‌کند تا دستکاری در تراکنش‌ها غیرممکن شود.

3.  **`consensus.rs` (موتور اجماع - Proof of Patience/Trust):**
    -   این فایل مغز متفکر شبکه است که تصمیم می‌گیرد "چه کسی حق دارد بلاک بعدی را بسازد؟"
    -   **NodeState**: برای هر نود در شبکه یک پرونده می‌سازد:
        -   `trust_score`: امتیاز اعتماد (اگر نود رفتار خوب داشته باشد بالا می‌رود، اگر قطعی داشته باشد یا بلاک بد بفرستد کم می‌شود).
        -   `uptime`: مدت زمانی که نود آنلاین بوده است.
    -   **Logic**: رهبر (Leader) نودی است که بالاترین ترکیب "امتیاز اعتماد" و "صبر" (زمان آنلاین بودن) را داشته باشد. این مکانیسم انرژی‌بر نیست اما امنیت بالایی دارد.

4.  **`p2p.rs` (شبکه و ارتباطات):**
    -   سنگین‌ترین و پیچیده‌ترین بخش کد.
    -   **Swarm**: مدیر تمام اتصالات شبکه.
    -   **Gossipsub**: پروتکلی که وقتی یک نود بلاک جدیدی پیدا می‌کند، آن را مثل "شایعه" به نودهای همسایه می‌گوید و در کسری از ثانیه کل شبکه باخبر می‌شوند.
    -   **Relay Logic**: اگر نود پشت فایروال یا روتر خانگی باشد، این بخش به طور خودکار به یک Relay Server متصل می‌شود تا بتواند با دیگران حرف بزند.

5.  **`storage.rs` (حافظه بلندمدت):**
    -   رابط کار با دیتابیس `Redb`.
    -   توابع `save_block`, `get_block`, `save_wallet`.
    -   **Pruning**: قابلیتی که نودهای سبک (Light Nodes) می‌توانند بلاک‌های خیلی قدیمی را پاک کنند تا فضای دیسک پر نشود.

---

## ۵. پروژه چگونه کار می‌کند؟ (Workflow)

### سناریو ۱: شروع به کار نود (Start Node)
1.  کاربر دکمه Start را می‌زند.
2.  Tauri دستور `start_node` را در `lib.rs` صدا می‌زند.
3.  سیستم دیتابیس را لود می‌کند.
4.  سرویس P2P (`start_p2p_node`) در یک ترد جداگانه (Background Thread) بالا می‌آید.
5.  نود شروع به کشف همسایه‌ها (`Discovering Peers`) می‌کند.
6.  اگر بلاک‌چین خالی باشد (نود اول)، "بلاک جنسیس" (Genesis Block) را خودش می‌سازد.
7.  اگر بلاک‌چین وجود داشته باشد، از همسایه‌ها درخواست `Sync` (همگام‌سازی) می‌کند تا آخرین بلاک‌ها را بگیرد.

### سناریو ۲: انجام تراکنش (Transaction Flow)
1.  کاربر در UI آدرس گیرنده و مبلغ را وارد می‌کند.
2.  UI دستور `submit_transaction` را صدا می‌زند.
3.  Rust چک می‌کند: آیا موجودی کافی است؟ آیا فرمت آدرس درست است؟
4.  تراکنش با کلید خصوصی کاربر امضا می‌شود.
5.  تراکنش به `Mempool` (استخر انتظار) اضافه می‌شود.
6.  تراکنش از طریق پروتکل Gossip به تمام نودهای دیگر شبکه ارسال می‌شود.

### سناریو ۳: ماینینگ و ساخت بلاک (Mining Flow)
1.  هر ۱۰ ثانیه، تمام نودها الگوریتم انتخاب رهبر (`select_leader` در `consensus.rs`) را اجرا می‌کنند.
2.  اگر نود شما انتخاب شود:
    -   تراکنش‌ها را از Mempool برمی‌دارد.
    -   کارمزدها را محاسبه می‌کند.
    -   یک مساله ریاضی کوچک (VDF) را حل می‌کند (به عنوان اثبات زمان).
    -   بلاک را می‌سازد و ذخیره می‌کند.
    -   بلاک را در شبکه پخش می‌کند.
    -   پاداش (Block Reward) به کیف پول شما واریز می‌شود.

---

## ۶. چرا این پروژه سریع و کارآمد است؟ (Performance Analysis)

1.  **بدون سربار ماشین مجازی (No VM Overhead):** برخلاف جاوا یا پایتون، Rust مستقیماً روی CPU اجرا می‌شود.
2.  **معماری رویداد محور (Event-Driven):** استفاده از `Tokio` باعث می‌شود که نود بتواند همزمان که در حال همگام‌سازی بلاک‌های قدیمی است، تراکنش‌های جدید را هم پردازش کند، بدون اینکه برنامه "گیر" (Freeze) کند.
3.  **دیتابیس Key-Value:** استفاده از `redb` به جای SQL باعث شده خواندن و نوشتن بلاک‌ها تقریباً آنی باشد (چون نیازی به پردازش کوئری‌های پیچیده نیست).
4.  **پروتکل باینری:** داده‌ها به صورت متن (JSON) در شبکه جابجا نمی‌شوند (مگر برای دیباگ)، بلکه به صورت بایت‌های فشرده (`bincode`) ارسال می‌شوند که حجم ترافیک را به شدت کم می‌کند.

## ۷. امنیت (Security)

1.  **رمزنگاری Ed25519:** غیرقابل شکستن با تکنولوژی‌های فعلی. امکان جعل امضا وجود ندارد.
2.  **VDF Proofs:** هیچ نودی نمی‌تواند بلاک‌ها را "پیش‌تولید" کند. باید زمان واقعی سپری شود. این جلوی حملات Spamming را می‌گیرد.
3.  **Sybil Resistance:** سیستم امتیاز دهی (`trust_score`) باعث می‌شود اگر کسی هزار نود جعلی بسازد، چون زمان فعالیت (Uptime) و سابقه ندارند، هیچ شانسی برای برنده شدن در ماینینگ نداشته باشند.

---

این داکیومنت نمایی کامل از معماری و جزئیات فنی پروژه Antigravity Chain است که نشان می‌دهد چگونه تمام اجزا به صورت منسجم و مهندسی شده کنار هم قرار گرفته‌اند.
